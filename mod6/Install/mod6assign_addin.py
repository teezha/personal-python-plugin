# -*- coding: utf-8 -*-
# ---------------------------------------------------------------------------
# mod6assign_addin.py
# Created on: 2017-03-03
#   (generated by python IDE)
# Usage: Adds feature layer, deletes feature layer, and exports map to PDF
# By: Toby Zhang
# Description: This script allows user to select a "Police Zone" or select the crime
#              data by drawing a rectangle. Users can create and add a summary table
#              from selected features and export the map to a pdf. The user can also
#              update author/date information on the layout and display a popup message for help.
# Dependencies: two inputs must be feature layers
# Program Limitations: Users can only output the entire map document as a pdf
#-----------------------------------------------------------------
import arcpy, os, pythonaddins, datetime

class AddTableandExport(object):
    def __init__(self):
        self.enabled = True
        self.checked = False
    def onClick(self):
        #Overwrite environment
        arcpy.env.overwriteOutput = True 
        
        # Get the current map document and the first data frame.
        mxd = arcpy.mapping.MapDocument('CURRENT')
        dataFrame = mxd.activeDataFrame
        
        #file path of the MapDocument
        outPath = mxd.filePath
        tablePath = os.path.dirname(outPath)+ r"/sumtab.dbf"

        #Delete the table from the clone 
        for dataFrame in arcpy.mapping.ListDataFrames(mxd):
            for table in arcpy.mapping.ListTableViews(mxd, "", dataFrame):
                if table.name.lower() == r"/sumtab.dbf":
                    arcpy.mapping.RemoveTableView(dataFrame, table)

        #Delete the table from disk
        arcpy.Delete_management(tablePath)

        #Find all the layout elements and delete them
        elementLayout = arcpy.mapping.ListLayoutElements(mxd, wildcard="*_clone*")

        for element in elementLayout:
            element.delete()
        
        #Reads a table and creates a new table
        arcpy.Frequency_analysis("Crime 1995", tablePath, ["crime95des.CRIMETYPE", "crime95des.DESCRIPT"])
        horzLine = arcpy.mapping.ListLayoutElements(mxd, "GRAPHIC_ELEMENT", "horzLine")[0]
        vertLine = arcpy.mapping.ListLayoutElements(mxd, "GRAPHIC_ELEMENT", "vertLine")[0]
        tableText = arcpy.mapping.ListLayoutElements(mxd, "TEXT_ELEMENT", "textElm")[0]

        #Get information about the table

        #find the table in map document
        listTables = arcpy.mapping.ListTableViews(mxd)
       
        for tables in listTables:
            if tables.name ==  "sumtab":
                sumTable = tables
                
        # count how many rows in table           

        numRows = int(arcpy.GetCount_management(sumTable).getOutput(0))
        rowHeight = 0.17
        fieldNames = ["FREQUENCY", "crime95d_1"]
        numColumns = len(fieldNames)
        colWidth = 2

        #Build lines based on upper left coordinates
        #Set the proper size of the original parent then clone it

        upX = 0.4
        upY = 1.85

        #vertical lines
        vertLine.elementPositionX = upX
        vertLine.elementPositionY = upY
        vertLine.elementHeight =(rowHeight * numRows) + rowHeight

        x = upX
        for vertical in range(1, numColumns+1):
            x = x + colWidth
            vert_clone = vertLine.clone("_clone")
            vert_clone.elementPositionX = x

        #Horizontal lines
        horzLine.elementPositionX = upX
        horzLine.elementPositionY = upY
        horzLine.elementWidth = numColumns * colWidth

        y = upY - rowHeight
        for horizontal in range(1, numRows +2 ):
            temp = horzLine.clone("_clone")
            temp.elementPositionY = y
            y = y - rowHeight 

        #Places text column names
        tableText.elementPositionX = upX + 0.4
        tableText.elementPositionY = upY
        tableText.text = fieldNames[0]
        accumulatedWidth = colWidth
        for field in range(1, numColumns):
            newField = tableText.clone("_clone")
            newField.text = fieldNames[field]
            if fieldNames[field] == "crime95d_1":
                newField.text = "Description"
            newField.elementPositionX = newField.elementPositionX + accumulatedWidth
            accumulatedWidth = accumulatedWidth + colWidth

        #Create text elements based on values from the table

        table = arcpy.SearchCursor(sumTable)
        y = upY - rowHeight
        for row in table:
            x = upX + 0.05
            for field in fieldNames:
                newCellText = tableText.clone("_clone")
                newCellText.text = row.getValue(field)
                newCellText.elementPositionX = x
                newCellText.elementPositionY = y
                accumulatedWidth = accumulatedWidth + colWidth
                x = x + colWidth
            y = y - rowHeight

        #Create the path of pdf
        outputPDF = os.path.dirname(outPath)+ r"/crimemap.pdf"
            
        
        #Export the file to PDF
        arcpy.mapping.ExportToPDF(mxd, outputPDF, dataFrame)

        

class Help(object):
    def __init__(self):
        self.enabled = True
        self.checked = False
    def onClick(self):
        pythonaddins.MessageBox('Drop Down Box: Select the Crimes based on Region Chosen'+'\n'+'Select Crimes Tool: Use the mouse to draw rectangles on map'+'\n'+'Add Table and Export: Adds the summary table to layout and Exports to pdf'+'\n'+'Update Name and Date: Updates author name and current date', 'Help', 0)

class SelectCrimes(object):
    def __init__(self):
        self.enabled = True
        self.cursor = 3
        self.shape = "Rectangle"

    def onMouseDown(self, x, y, button, shift):
        pass
    def onMouseDownMap(self, x, y, button, shift):
        pass
    def onMouseUp(self, x, y, button, shift):
        pass
    def onMouseUpMap(self, x, y, button, shift):
        pass
    def onMouseMove(self, x, y, button, shift):
        pass
    def onMouseMoveMap(self, x, y, button, shift):
        pass
    def onDblClick(self):
        pass
    def onKeyDown(self, keycode, shift):
        pass
    def onKeyUp(self, keycode, shift):
        pass
    def deactivate(self):
        pass
    def onCircle(self, circle_geometry):
        pass
    def onLine(self, line_geometry):
        pass
    def onRectangle(self, rectangle_geometry): 

        #assign variables
        extent = rectangle_geometry
        recXMin = extent.XMin
        recYMin = extent.YMin
        recXMax = extent.XMax
        recYMax = extent.YMax

        #select the upper left corner and make a point 
        upperLeft = convertCoords(recXMin, recYMax)
        pointUL = arcpy.Point(upperLeft[0], upperLeft[1])

        #select the upper right corner and make a point
        upperRight = convertCoords(recXMax, recYMax)
        pointUR = arcpy.Point(upperRight[0], upperRight[1])

        #select the lower right corner and make a point
        lowerRight = convertCoords(recXMax, recYMin)
        pointLR = arcpy.Point(lowerRight[0], lowerRight[1])

        #select the lower left corner and make a point
        lowerLeft = convertCoords(recXMin, recYMin)
        pointLL = arcpy.Point(lowerLeft[0], lowerRight[1])

        a = arcpy.Array()
        a.add(pointUL)
        a.add(pointUR)
        a.add(pointLR)
        a.add(pointLL)
        a.add(pointUL)
        outPolygon = arcpy.Polygon(a)
        
        
        #After you get your extent, select the features in a layer named 'Crime'
        mxd = arcpy.mapping.MapDocument("CURRENT")
        dataFrame = mxd.activeDataFrame
        extent = dataFrame.extent
        layers = arcpy.mapping.ListLayers(mxd, "Crime 1995", dataFrame)[0]
        arcpy.SelectLayerByLocation_management(layers, "INTERSECT", outPolygon, 0, "NEW_SELECTION")

        del mxd

class SelectRegion(object):
    def __init__(self):
        self.items = ["EAST SIDE", "WEST END", "WEST SIDE"]
        self.editable = True
        self.enabled = True
        self.dropdownWidth = 'WWWWWWWWW'
        self.width = 'WWWWWWWWW'
    def onSelChange(self, selection):

        #Clear selection
        arcpy.SelectLayerByAttribute_management("Police Zones", "CLEAR_SELECTION")
        arcpy.SelectLayerByAttribute_management("Crime 1995", "CLEAR_SELECTION")

        
        # Get the current map document and the first data frame.
        mxd = arcpy.mapping.MapDocument('CURRENT')

        #Get the current data frame
        dataFrame = arcpy.mapping.ListDataFrames(mxd, "CrimeData")[0]

        #List layer of Region
        layer = arcpy.mapping.ListLayers(mxd,"Police Zones",dataFrame)

        #Select region of the police zone
        selectRegion = "REGION = '%s'" % selection.upper()

        #Select attribute in the region
        arcpy.SelectLayerByAttribute_management("Police Zones","NEW_SELECTION", selectRegion)
            
        #Select crime data within the selected region
        arcpy.SelectLayerByLocation_management("Crime 1995", "INTERSECT","Police Zones")

        del mxd
        
    def onEditChange(self, text):
        pass
    def onFocus(self, focused):
        # When the combo box has focus, update the combo box with the list of layer names.
                if focused:
                        self.mxd = arcpy.mapping.MapDocument('CURRENT')
                        dataFrame = arcpy.mapping.ListDataFrames(self.mxd, "CrimeData")[0]
                        layer = arcpy.mapping.ListLayers(self.mxd,"Police Zones", dataFrame)
                        
                        
    def onEnter(self):
        pass
    def refresh(self):
        pass

class UpdateNameandDate(object):
    def __init__(self):
        self.enabled = True
        self.checked = False
    def onClick(self):
        # Get the current map document and the first data frame.
        mxd = arcpy.mapping.MapDocument('CURRENT')

        #Update the name and the date of the text element
        for TextElement in arcpy.mapping.ListLayoutElements(mxd, "TEXT_ELEMENT"):
            if TextElement.name == "CrimeAuthor":
                TextElement.text = "Author: Toby Zhang"
            if TextElement.name == "CrimeDate":
                today = datetime.date.today()
                TextElement.text = today.strftime("%B %d, %Y")

        #Refresh the view of data frames
        arcpy.RefreshActiveView()
        arcpy.RefreshTOC()
            
def convertCoords(x,y):
        thisMap = arcpy.mapping.MapDocument("CURRENT")
        dataFrame = arcpy.mapping.ListDataFrames(thisMap)[0]
        pageX = x
        pageY = y

        #get the data frame dimensions in page units
        df_page_w = dataFrame.elementWidth
        df_page_h = dataFrame.elementHeight
        df_page_x_min = dataFrame.elementPositionX
        df_page_y_min = dataFrame.elementPositionY
        df_page_x_max = df_page_w + df_page_x_min
        df_page_y_max = df_page_h + df_page_y_min

        #get the data frame extent in projected coordinates
        df_min_x = dataFrame.extent.XMin
        df_min_y = dataFrame.extent.YMin
        df_max_x = dataFrame.extent.XMax
        df_max_y = dataFrame.extent.YMax
        df_proj_w = dataFrame.extent.width
        df_proj_h = dataFrame.extent.height
        #ensure the coordinates are in the extent of the data frame
        if pageX < df_page_x_min or pageX > df_page_x_max:
            pythonaddins.MessageBox('X coordinate is not within map portion of the page.', "Out of Bounds")
            return 0,0
        if pageY < df_page_y_min or pageY > df_page_y_max:
            pythonaddins.MessageBox('Y coordinate is not within map portion of the page.', "Out of Bounds")
            return 0,0

        #scale the projected coordinates to map units from the lower left of the data frame
        scale = dataFrame.scale/39.3701
        map_x = df_min_x + ((pageX - df_page_x_min)*scale)
        map_y = df_min_y + ((pageY - df_page_y_min)*scale)

        return map_x,map_y